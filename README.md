# robocode
Team Members: Andrew Kim, Kobe Lee
CS 141

	One of the first things we did when beginning our project was randomly placing five to six premade robots into a battle arena and observing which robots performed the best. After several tests, we came to a conclusion that the CornerBot had the most consistent and sufficient results. However, a flaw we noticed in its performance was that it remained in the corner the entire round. This put it in a very vulnerable position in situations where the other robots found it right away. To combat this, we wanted to create a robot that would hug a wall and continuously move back and forth while shooting at the other robots. The first obstacle we ran into was that the starting position of the robot was not always horizontal or vertical. To fix this issue, we created a formula that will be explained later that would force the robot to turn to a wall before making its move. The robot would then travel straight to the wall, and once hitting the wall, it would turn to the left and move down. Our main reason for having the robot hug a wall was to minimize the possibility of getting hit from multiple directions. By having it right on the wall, we were cutting half of the possible angles to be shot from. Also, we made sure to have the gun rotate in a 180 degree range that was facing away from the wall. There was no need to have it turn all the way around because the other 180 degrees was facing a dead wall. This shorter range of motion allowed the robot to constantly see other robots and shoot more frequently. We also implemented a shoot-and-go system of movement that had the robot stop, shoot, and then move again. This was helpful in cases where the other robots would predict our movement based on our current velocity. The stops our robots made were somewhat able to combat their predictive shooting. Although our robot did not perform too well in the tournament, we were still happy to see that it worked the way we intended and was able to win a couple rounds against some formidable opponents. Given that we almost never got under twenty percent in winning percentage, with the exclusion of the final fights with all the robots, we certainly had acceptable results. 

	Because our program was made to make sure the robot went straight into a wall before making any movements, we initialized an int count to 0 which would be used in the OnHitWall() method. To begin, the run() method would be run right after the initialization of the count variable. We set our colors using the setColors method just to spice things up a bit. Also, the plain blue color looked a bit bland. As mentioned in the previous paragraph, the first obstacle we faced was the robot not directly facing a wall. We fixed this issue by using the getHeading() method in line 24 and assigning the value to a double x. The getHeading() method returned a degree value from 0 to 360 with 0 being directly to the right and increasing counterclockwise. So we used a series of if-else-if statements to create four possible scenarios. The first if statement was that if the degree value was less than or equal to 90, we subtracted the given degree from 90 and made it turn right by the difference. We did the same thing for all four scenarios, except we inserted 180, 270, and 360 for 90 as the given degree values increased. Now that we have the robot facing a wall, we made the robot go straight using ahead(800). Our reason for using 800 as the value was because the arena’s default length was 800. When going ahead by this distance, the robot was guaranteed to hit a wall. Once hitting the wall, the onHitWall() method would be run. Everytime this method is run, the count variable we initialized at the beginning of the program is incremented by one. In line 97 we wrote an if-else statement with a condition that if count equals 1, that the robot would simply back up by 10. This would only happen when the robot hits the first wall. The else statement states that when the count number is anything but 1 (can never be 0 in this method), the robot would turn right by 180 degrees. After the first run of onHitWall(), the control of the program moves back to line 38, which commands the robot to turn the gun to the right by 180 degrees using turnGunRight(180). Then the program commands the bot to turn right using turnRight(90). After this first block of movement, we implemented two while loops. The first was in the event that count equaled either 1 or an odd number. This while loop required the gun to continuously turn left 180 degrees and then to the right by 180 degrees, and to move ahead by 100. The second while loop was for count equaling an even number. It required the robot to turn opposite of what it would do in the first loop, with the gun turning right by 180 and then left 180 continuously, and then move ahead by 100. The main reason for implementing these two different while loops was to make sure the robot’s gun was always facing the rest of the arena. For our shooting method, we used the onScannedRobot() method. Inside the method we used the getDistance() to find how far a single robot was. With the value returned, we set it to the variable distance. We then use a series of if-else statements to determine the robot’s firing power. Because the strong firepower had a drawback of draining more energy, we made sure to make the power weaker as the distance of the robot increased. So our first if statement was for if the distance was less than 200. In this case, we sent the largest possible variable of 3 to the fire() method. Then as the distances increased through the if statements, we decreased the firepower, which led to a lowest power of 0.7. The last problem we encountered in our test runs was when the robot ran into other robots, it would continue to run into them until they moved. To combat this, we had the initial movement when hitting a robot to move back by 60 using back(60) in line 83. Then we added an if statement of if the count variable equalled 1, then the robot would just go ahead(800) to another wall for safety. 

	In order to test our robot, the first requirement would be the successful installation of Robocode. This could be done by navigating the following link and following its instructions on downloading the program:http://web.archive.org/web/20170403143550/http://robowiki.net/wiki/Robocode_Download_And_Install . From that point, upon start-up of the program, you will need to create a new robot by going to the “Robot” tab and then selecting “Source Editor”. From there, copy and paste the code from our robot (the file called TeamKorea.java), but change the name of the robot in our code to fit whatever name you please for your robot. Upon doing so, save and compile the code; from there, you will be prompted to provide a package directory and name for your robot. Select a convenient location on your computer to store the robot data, as well as a name that you would like to maintain for the robot at all times. Once the saving and compiling process completes, there will be a “.class” file in the directory that you selected for your robocode to go into. From there, to run the robot, you must go back to the main application that first booted up on startup, and then go to the “Battle” tab. From there, select “New” and then add your robot with your robot’s name as well as any others that you wish to see the robot combat. From that point, you could experiment with a number of various robots and see both the strengths and weaknesses of the robots and thus make adjustments accordingly. By going to the source editor, it is possible to change various variables within the robot, such as the power of the shots and the movements. Some movement algorithms are far more complex than others and therefore require more thinking. One particular robot’s behavior that might be especially worth paying attention to is the spin bot. Capable of spinning in a smooth, circular motion, the robot is effective in combat both with many other robots present and on its own. You could also adjust the speed of the battles to make the simulations run faster to collect data, or change the size of the field and number of robots for each simulation. By doing so, it is possible to obtain a firm understanding of how the robot performs both when there is a large number of other robots to battle and when there is a small number of robots that the robot must fight. When you want to re-access your robot in the future, you must go through the command line (if you have a Windows computer) or the Terminal (if you have a Mac), and use the command initially specified within the previously provided website. From there, the code will load upon going through  your computer for the directory that you selected as the location for all of your code. 
